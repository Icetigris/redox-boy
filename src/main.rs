#![allow(non_snake_case)]
const BIOS_ROM: [u8; 256] = [
0x31,0xfe, 0xff,0xaf, 0x21,0xff, 0x9f,0x32, 0xcb,0x7c, 0x20,0xfb, 0x21,0x26, 0xff,0x0e,
0x11,0x3e, 0x80,0x32, 0xe2,0x0c, 0x3e,0xf3, 0xe2,0x32, 0x3e,0x77, 0x77,0x3e, 0xfc,0xe0,
0x47,0x11, 0x04,0x01, 0x21,0x10, 0x80,0x1a, 0xcd,0x95, 0x00,0xcd, 0x96,0x00, 0x13,0x7b,
0xfe,0x34, 0x20,0xf3, 0x11,0xd8, 0x00,0x06, 0x08,0x1a, 0x13,0x22, 0x23,0x05, 0x20,0xf9,
0x3e,0x19, 0xea,0x10, 0x99,0x21, 0x2f,0x99, 0x0e,0x0c, 0x3d,0x28, 0x08,0x32, 0x0d,0x20,
0xf9,0x2e, 0x0f,0x18, 0xf3,0x67, 0x3e,0x64, 0x57,0xe0, 0x42,0x3e, 0x91,0xe0, 0x40,0x04,
0x1e,0x02, 0x0e,0x0c, 0xf0,0x44, 0xfe,0x90, 0x20,0xfa, 0x0d,0x20, 0xf7,0x1d, 0x20,0xf2,
0x0e,0x13, 0x24,0x7c, 0x1e,0x83, 0xfe,0x62, 0x28,0x06, 0x1e,0xc1, 0xfe,0x64, 0x20,0x06,
0x7b,0xe2, 0x0c,0x3e, 0x87,0xe2, 0xf0,0x42, 0x90,0xe0, 0x42,0x15, 0x20,0xd2, 0x05,0x20,
0x4f,0x16, 0x20,0x18, 0xcb,0x4f, 0x06,0x04, 0xc5,0xcb, 0x11,0x17, 0xc1,0xcb, 0x11,0x17,
0x05,0x20, 0xf5,0x22, 0x23,0x22, 0x23,0xc9, 0xce,0xed, 0x66,0x66, 0xcc,0x0d, 0x00,0x0b,
0x03,0x73, 0x00,0x83, 0x00,0x0c, 0x00,0x0d, 0x00,0x08, 0x11,0x1f, 0x88,0x89, 0x00,0x0e,
0xdc,0xcc, 0x6e,0xe6, 0xdd,0xdd, 0xd9,0x99, 0xbb,0xbb, 0x67,0x63, 0x6e,0x0e, 0xec,0xcc,
0xdd,0xdc, 0x99,0x9f, 0xbb,0xb9, 0x33,0x3e, 0x3c,0x42, 0xb9,0xa5, 0xb9,0xa5, 0x42,0x3c,
0x21,0x04, 0x01,0x11, 0xa8,0x00, 0x1a,0x13, 0xbe,0x20, 0xfe,0x23, 0x7d,0xfe, 0x34,0x20,
0xf5,0x06, 0x19,0x78, 0x86,0x23, 0x05,0x20, 0xfb,0x86, 0x20,0xfe, 0x3e,0x01, 0xe0,0x50];

fn PCReadByte(memory: &[u8; 65536], cycles: &mut u32, PC: &mut u16) -> u8
{
    let byte = memory[*PC as usize];
    (*PC) += 1;
    (*cycles) += 4;
    return byte;
}

fn WriteByte(memory: &mut [u8; 65536], cycles: &mut u32, byte: u8, writeDest: u16)
{
    memory[writeDest as usize] = byte;
    (*cycles) += 4;
}

fn WriteHL(cycles: &mut u32, hl: u16, H: &mut u8, L: &mut u8)
{
    *H = (hl >> 8) as u8;
    *L = (0x00ff & hl) as u8;
    (*cycles) += 4;
}

fn main()
{    
    //CPU
    //registers
    let mut A: u8 = 0; //accumulator
    let mut F: u8 = 0; //flags: [Z, N, H, C, -, -, -, -]
                        //Z = zero, N = negative, H = half-carry, C = carry
    let mut B: u8 = 0;
    let mut C: u8 = 0;

    let mut D: u8 = 0;
    let mut E: u8 = 0;

    let mut H: u8 = 0;
    let mut L: u8 = 0;
    // HL can hold a memory address, which you can put into SP with LD SP,HL

    let mut SP: u16 = 0; //stack pointer
    let mut PC: u16 = 0;

    let mut cpuCycles: u32 = 0;

    //MMU
    //address space
    let mut memory: [u8; 65536] = [0; 65536];
    memory[..256].clone_from_slice(&BIOS_ROM);

    loop
    {
        //PC == 0 at start
        println!{"current byte at {:04x}: {:02x}", PC, memory[PC as usize]};

        //instruction decode
        let currentByte = PCReadByte(&memory, &mut cpuCycles, &mut PC);
        match currentByte
        {
            0x00 => println!("NOP"),
            0x10 => println!("STOP"),

            // 16-bit loads
            0x01 => println!("LD BC, d16"),
            0x11 => println!("LD DE, d16"),
            0x21 => 
            {
                L = PCReadByte(&memory, &mut cpuCycles, &mut PC);
                H = PCReadByte(&memory, &mut cpuCycles, &mut PC);
                println!("LD HL, ${:02x}{:02x}", H, L);
            },
            0x31 => 
            {
                SP = PCReadByte(&memory, &mut cpuCycles, &mut PC) as u16;
                SP |= (PCReadByte(&memory, &mut cpuCycles, &mut PC) as u16) << 8;
                println!("LD SP, ${:04x}", SP);
            },
            0x32 => 
            {
                //memory[HL] = A
                //HL--
                let hl: u16 = ((H as u16) << 8) | (L as u16);
                println!("mem at {:04x}: {:04x}", hl, memory[hl as usize]);
                WriteByte(&mut memory, &mut cpuCycles, A, hl);
                println!("HL, ${:02x}{:02x}", H, L);
                WriteHL(&mut cpuCycles, hl - 1, &mut H, &mut L);
                println!("HL, ${:02x}{:02x}", H, L);
                println!("LD (HL-), A", );
            },
            // XORs
            0xaf =>
            {
                A ^= A;
                if A == 0
                {
                    F = 0x8; // 1000
                }
                println!("XOR A: ${:04x}", A);
                println!("F (ZNHC): {:02b}", F);
            },
            0xa8 =>
            {
                A ^= B;
                if A == 0
                {
                    F = 0x8; // 1000
                }
                println!("XOR A, B: ${:04x}, ${:04x}", A, B);
                println!("F (ZNHC): {:02b}", F);
            },
            0xa9 => println!("XOR C"),
            0xaa => println!("XOR D"),
            0xab => println!("XOR E"),
            0xac => println!("XOR H"),
            0xad => println!("XOR L"),
            0xae => println!("XOR HL"),
            0xee => println!("XOR d8"),

            _ => println!("not an opcode"),
        }

        if PC > 255
        {
            break;
        }
    }
}
